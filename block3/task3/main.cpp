/*
# K. Менеджер памяти-1

## Задача

- Ограничение времени	1 секунда
- Ограничение памяти	188Gb
- Ввод	стандартный ввод или input.txt
- Вывод	стандартный вывод или output.txt

Пете поручили написать менеджер памяти для новой стандартной библиотеки языка \varphi++. В распоряжении у менеджера находится массив из N последовательных ячеек памяти, пронумерованных от 1 до N. Задача менеджера – обрабатывать запросы приложений на выделение и освобождение памяти. Запрос на выделение памяти имеет один параметр K. Такой запрос означает, что приложение просит выделить ему K последовательных ячеек памяти. Если в распоряжении менеджера есть хотя бы один свободный блок из K последовательных ячеек, то он обязан в ответ на запрос выделить такой блок. При этом непосредственно перед самой первой ячейкой памяти выделяемого блока не должно располагаться свободной ячейки памяти. После этого выделенные ячейки становятся занятыми и не могут быть использованы для выделения памяти, пока не будут освобождены. Если блока из K последовательных свободных ячеек нет, то запрос отклоняется. Запрос на освобождение памяти имеет один параметр T. Такой запрос означает, что менеджер должен освободить память, выделенную ранее при обработке запроса с порядковым номером T. Запросы нумеруются, начиная с единицы. Гарантируется, что запрос с номером T – запрос на выделение, причем к нему еще не применялось освобождение памяти. Освобожденные ячейки могут снова быть использованы для выделения памяти. Если запрос с номером T был отклонен, то текущий запрос на освобождение памяти игнорируется. Требуется написать менеджер памяти, удовлетворяющий приведенным критериям.

## Формат ввода

Первая строка входного файла содержит числа N и M – количество ячеек памяти и количество запросов соответственно (1 ≤ N ≤ 2^31 - 1; 1 ≤ M ≤ 10^5). Каждая из следующих M строк содержит по одному числу: (i+1)-я строка входного файла (1 ≤ i ≤ M) содержит либо положительное число K, если i-й запрос – запрос на выделение с параметром K (1 ≤ K ≤ N), либо отрицательное число -T, если i-й запрос – запрос на освобождение с параметром T (1 ≤ T < i).

## Формат вывода

Для каждого запроса на выделение памяти выведите в выходной файл результат обработки этого запроса: для успешных запросов выведите номер первой ячейки памяти в выделенном блоке, для отклоненных запросов выведите число -1. Результаты нужно выводить в порядке следования запросов во входном файле.


## Примеры

### Пример 1
Ввод:
```
42 9
7
3
8
-2
6
5
-5
9
4
```

Вывод:
```
1
8
11
19
25
30
19
```

### Пример 2
Ввод:
```
128 12
1
2
4
-2
8
-3
16
-5
32
-7
64
-1
```

Вывод:
```
1
2
4
8
16
32
64
```
*/

#include <iostream>
#include <map>

struct block {
    int32_t start;
    int32_t end;
};

int main(int argc, char** argv) {
    using namespace std;
    // n - количество ячеек памяти, m - количество запросов
    int32_t n, m;
    cin >> n >> m;
    // map номер -> блок, занятые блоки, отсортированные по номеру
    map<int32_t, block> number_block;
    // multimap размер -> блок, освобождённые блоки, отсортированные по размеру
    multimap<int32_t, block> size_block;
    // map начало -> блок, освобождённые блоки, отсортированные по началу
    map<int32_t, block> start_block;

    int32_t query;
    cin >> query;
    // Заполняем самый первый блок
    number_block[1] = { 1, query };
    cout << 1 << endl;

    // Заполняем свободное пространство
    size_block.insert({n - query, { query + 1, n } });
    start_block[query + 1] = { query + 1, n };

    for (int32_t i = 2; i <= m; i++) {
        cin >> query;
        // Запрос на выделение памяти
        if (query > 0) {
            int32_t block_size = query;
            // Поиск блока из освобождённых, в который можно влезть
            auto it = size_block.lower_bound(block_size);
            if (it != size_block.end()) {
                // Найден блок, который подходит по размеру
                block b = it->second;
                // Удаляем его из освобождённых блоков
                size_block.erase(it);
                // Удаляем его также из блоков, отсортированных по началу
                start_block.erase(b.start);
                // Разбиваем блок на две части, если блок больше запрашиваемого размера
                if (b.end - b.start > block_size) {
                    // Добавляем оставшуюся часть блока в освобождённые блоки
                    size_block.insert({ b.end - block_size, {b.start + block_size, b.end} });
                    // Добавляем оставшуюся часть блока в блоки, отсортированные по началу
                    start_block[b.start + block_size] = {b.start + block_size, b.end};
                }
                // Обновляем информацию о выделенном блоке
                number_block[i] = { b.start, b.start + block_size };
                // Выводим номер первой ячейки памяти в выделенном блоке
                cout << b.start << endl;
            } else {
                // Не удалось найти подходящий блок
                cout << -1 << endl;
            }
        }
        // Если запрос на освобождение памяти
        else if (query < 0) {
            int32_t number = -query;
            block b = number_block[number];
            // Убираем блок из занятых
            number_block.erase(number);
            // Добавляем в освобождённые, отсортрированные по размеру
            size_block.insert({ b.end - b.start, b });
            // Добавляем в освобождённые, отсортрированные по началу
            start_block[b.start] = b;
        }
    }
    return 0;
}